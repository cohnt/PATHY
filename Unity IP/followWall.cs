using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class followWall : MonoBehaviour {

	// Use this for initialization
	void solveMaze (Texture2D pmaze, bool[,] vector) {
		//algorithm test

		Texture2D smaze = pmaze; //pmaze should be a photo of the maze or the processed maze image.
		// this class also needs access to the vector that is generated by the image processing script

		//position we are evaluating
		int posX = 152; //these should be initalized to the starting cords
		int posY = 15;

		int endX = 124; //these are the ending cords
		int endY = 162;

		int direction = 1; //int to hold direction 0 = right 1 = left 2 = up 3 = down
		int pdir = 1;

		//get us against a wall
		while (vector [posX, posY - 1] == false) {
			posY--;
			smaze.SetPixel (posX, posY, Color.red);
		}

		int iter = 0;

		bool unsolved = true;
		while(unsolved) {
			if (direction == 0) {
				if (vector [posX + 1, posY] == false && (vector [posX, posY - 1] == true || vector [posX, posY + 1] == true)) {
					posX++;
				} else {
					if (vector [posX, posY - 1] == false && (vector [posX + 1, posY - 1] == true || vector [posX - 1, posY - 1] == true)) {
						direction = 3;
						posY--;
					} else if (vector [posX, posY + 1] == false && (vector [posX + 1, posY + 1] == true || vector [posX - 1, posY + 1] == true)) {
						direction = 2;
						posY++;
					} else if (vector [posX, posY + 1] == false) {
						direction = 2;
						posY++;
					} else if (vector [posX, posY - 1] == false) {
						direction = 3;
						posY--;
					} else {
						vector [posX, posY] = true;
						posX--;
					}
				}
			} else if (direction == 1) {
				if (vector [posX - 1, posY] == false && (vector [posX, posY - 1] == true || vector [posX, posY + 1] == true)) {
					posX--;
				} else {
					if (vector [posX, posY - 1] == false && (vector [posX + 1, posY - 1] == true || vector [posX - 1, posY - 1] == true)) {
						direction = 3;
						posY--;
					} else if (vector [posX, posY + 1] == false && (vector [posX + 1, posY + 1] == true || vector [posX - 1, posY + 1] == true)) {
						direction = 2;
						posY++;
					} else if (vector [posX, posY + 1] == false) {
						direction = 2;
						posY++;
					} else if (vector [posX, posY - 1] == false) {
						direction = 3;
						posY--;
					} else {
						vector [posX, posY] = true;
						posX++;
					}
				}
			} else if (direction == 2) {
				if (vector [posX, posY + 1] == false && (vector [posX - 1, posY] == true || vector [posX + 1, posY] == true)) {
					posY++;
				} else {
					if (vector [posX + 1, posY] == false && (vector [posX + 1, posY + 1] == true || vector [posX + 1, posY - 1] == true)) {
						direction = 0;
						posX++;
					} else if (vector [posX - 1, posY] == false && (vector [posX - 1, posY + 1] == true || vector [posX - 1, posY - 1] == true)) {
						posX--;
						direction = 1;
					} else if (vector [posX + 1, posY] == false) {
						direction = 0;
						posX++;
					} else if (vector [posX - 1, posY] == false) {
						direction = 1;
						posX--;
					} else {
						vector [posX, posY] = true;
						posY--;
					}
				}
			} else if (direction == 3) {
				if (vector [posX, posY - 1] == false && (vector [posX - 1, posY] == true || vector [posX + 1, posY] == true)) {
					posY--;
				} else {
					if (vector [posX + 1, posY] == false && (vector [posX + 1, posY + 1] == true || vector [posX + 1, posY - 1] == true)) {
						direction = 0;
						posX++;
					}
					else if (vector [posX - 1, posY] == false && (vector [posX - 1, posY + 1] == true || vector [posX - 1, posY - 1] == true)) {
						direction = 1;
						posX--;
					} else if (vector [posX + 1, posY] == false) {
						direction = 0;
						posX++;
					} else if (vector [posX - 1, posY] == false) {
						direction = 1;
						posX--;
					} else {
						vector [posX, posY] = true;
						posY++;
					}
				} 
			}

			smaze.SetPixel (posX, posY, Color.red); //draw pixel (KEEPS TRACK OF CURRENT VECTOR POSTION) (BASICALLY RECORDS EVERY MOVE BEING MADE PER ITERATION).


			//condition if maze is solved
			if (posX > endX - 10 && posX < endX + 10) {
				if (posY > endY - 10 && posY < endY + 10) {
					unsolved = false;
				}
			}
			iter++;
			if (iter > 100000) { //cap iterations so no infinite loop
				unsolved = false;
			}
		}
	}
}
